// Time O(n*logn) solution here, very tricky but interesting - https://zhuanlan.zhihu.com/p/136706801
// Space O(n)
/*
dp[i] 表示长度为 i + 1 的所有上升子序列的末尾的最小值。

nums = [10,9,2,5,3,7,101,18]

开始没有数字
dp = []

1----------------------------
10  9  2  5  3  7  101  18
^   

先考虑 10, 只有 1 个数字, 此时长度为 1 的最长上升子序列末尾的值就是 10
len   1
dp = [10]

2----------------------------
10  9  2  5  3  7  101  18
    ^  
考虑 9, 9 比之前长度为 1 的最长上升子序列末尾的最小值 10 小, 更新长度为 1 的最长上升子序列末尾的值为 9
len   1
dp = [9]    

3----------------------------
10  9  2  5  3  7  101  18
       ^  
考虑 2, 2 比之前长度为 1 的最长上升子序列末尾的最小值 9 小, 更新长度为 1 的最长上升子序列末尾的值为 2
len   1
dp = [2]    

4----------------------------
10  9  2  5  3  7  101  18
          ^  
考虑 5, 
5 比之前长度为 1 的最长上升子序列末尾的最小值 2 大, 
此时可以扩展长度, 更新长度为 2 的最长上升子序列末尾的值为 5
len   1  2
dp = [2  5]   

5----------------------------
10  9  2  5  3  7  101  18
             ^  
考虑 3, 
3 比之前长度为 1 的最长上升子序列末尾的最小值 2 大, 向后考虑
3 比之前长度为 2 的最长上升子序列末尾的最小值 5 小, 更新长度为 2 的最长上升子序列末尾的值为 3
len   1  2
dp = [2  3]   

6----------------------------
10  9  2  5  3  7  101  18
                ^  
考虑 7, 
7 比之前长度为 1 的最长上升子序列末尾的最小值 2 大, 向后考虑
7 比之前长度为 2 的最长上升子序列末尾的最小值 3 大, 向后考虑
此时可以扩展长度, 更新长度为 3 的最长上升子序列末尾的值为 7
len   1  2  3
dp = [2  3  7]  

7----------------------------
10  9  2  5  3  7  101  18
                    ^  
考虑 101, 
101 比之前长度为 1 的最长上升子序列末尾的最小值 2 大, 向后考虑
101 比之前长度为 2 的最长上升子序列末尾的最小值 3 大, 向后考虑
101 比之前长度为 3 的最长上升子序列末尾的最小值 7 大, 向后考虑
此时可以扩展长度, 更新长度为 4 的最长上升子序列末尾的值为 101
len   1  2  3   4
dp = [2  3  7  101]  

8----------------------------
10  9  2  5  3  7  101  18
                        ^  
考虑 18, 
18 比之前长度为 1 的最长上升子序列末尾的最小值 2 大, 向后考虑
18 比之前长度为 2 的最长上升子序列末尾的最小值 3 大, 向后考虑
18 比之前长度为 3 的最长上升子序列末尾的最小值 7 大, 向后考虑
3 比之前长度为 4 的最长上升子序列末尾的最小值 101 小, 更新长度为 4 的最长上升子序列末尾的值为 18
len   1  2  3   4
dp = [2  3  7   18] 

遍历完成，所以数字都考虑了，此时 dp 的长度就是最长上升子序列的长度
*/
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.empty()) return 0;
        // dp[i] 表示长度为 i + 1 的所有上升子序列的末尾的最小值
        vector<int> dp{nums[0]};
        for (const auto& num : nums) {
            if (num < dp[0]) dp[0] = num;
            else if (num > dp.back()) dp.push_back(num);
            else {
                int left = 0, right = dp.size();
                while (left < right) {
                    int mid = left + (right - left) / 2;
                    if (dp[mid] < num) left = mid + 1;
                    else right = mid;
                }
                dp[right] = num;
            }
        }
        return dp.size();
    }
};

// Time O(n^2)
// Space O(n)
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.empty()) {
            return 0;
        }
        vector<int> dp(nums.size(), 0);
        dp[0] = 1;
        int maxans = 1;
        for (int i = 1; i < dp.size(); i++) {
            int maxval = 0;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    maxval = max(maxval, dp[j]);
                }
            }
            dp[i] = maxval + 1;
            maxans = max(maxans, dp[i]);
        }
        return maxans;
    }
};
