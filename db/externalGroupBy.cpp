// C++ program to implement External GroupBy
// Author: Ziqi Fan
#include <iostream>
#include <vector>
#include <fstream>
#include <cmath>
#include <queue>
using namespace std;

static int memoryLimitInBytes = 0;
static int num_ways = 0;

// Store each input key and value
struct KVPair
{
    string key;
    string value;
};

struct MinHeapNode
{
    // The element to be stored
    KVPair element;
    // index of the array from which the element is taken
    int i;
};

// Priority queue is used to do the K merge sort
// K here means the number of temporary files created after func splitInputFile()
// comp is a self defined comparator to sort first by key then by value
auto comp = [](MinHeapNode& a, MinHeapNode& b) {
    if(a.element.key == b.element.key) {
        return a.element.value > b.element.value;
    }
    return a.element.key > b.element.key;
};
priority_queue<MinHeapNode, vector<MinHeapNode>, decltype(comp)> pq(comp);

FILE* openFile(char* fileName, char* mode) {
    FILE* fp = fopen(fileName, mode);
    if (fp == NULL)
    {
        cerr << "Error while opening the file." << endl;
        exit(EXIT_FAILURE);
    }
    return fp;
}

// Merges k sorted files
void mergeTempFiles() {
    FILE* in[num_ways];
    for (int i = 0; i < num_ways; i++) {
        char fileName[20];

        // convert i to string
        snprintf(fileName, sizeof(fileName), "tempFile%d", i);

        // Open output files in read mode.
        in[i] = openFile(fileName, (char*)"r");
    }

    int i;
    char key[100];
    char value[100];
    for (i = 0; i < num_ways; i++) {
        // break if no output file is empty and
        // index i will be no. of input file
        if (fscanf(in[i], "%s %s\n", key, value) != 2)
            break;
        MinHeapNode node;
        node.element.key = key;
        node.element.value = value;
        node.i = i;
        pq.push(node);
    }

    int count = 0;

    // Now one by one get the minimum element from
    // priority queue and replace it with next element.
    // Run till all input files reach EOF
    bool firstLine = true;
    MinHeapNode prev;
    while (count != i) {
        // Get the minimum element and store it in output file
        MinHeapNode root = pq.top();
        pq.pop();

        if(root.element.key == prev.element.key) {
            cout << " " <<root.element.value;
        }
        else {
            if(firstLine) {
                cout << root.element.key << " " << root.element.value;
                firstLine = false;
            }
            else {
                cout << endl << root.element.key << " " << root.element.value;
            }
        }

        prev = root;

        // Find the next element that will replace current
        // root of heap. The next element belongs to same
        // input file as the current min element.
        if (fscanf(in[root.i], "%s %s\n", key, value) != 2) {
            count++;
        }
        else {
            root.element.key = key;
            root.element.value = value;
            pq.push(root);
        }
    }

    // close input and output files
    for (int i = 0; i < num_ways; i++) {
        fclose(in[i]);
    }

    // Add a new line at the end of file to make my output
    // the same as the output generated by the example scripts
    cout << endl;
}

// calculate the size of input file
ifstream::pos_type filesize(const char* filename) {
    ifstream in(filename, ifstream::ate | ifstream::binary);
    return in.tellg();
}

// Split the input file according to memory limitation to smaller files
// The smaller files are sorted based on key (if keys the same, then base on value)
void splitInputFile(char *input_file) {
    // For big input file
    FILE *in = openFile(input_file, (char*)"r");

    if(fscanf(in, "%d\n", &memoryLimitInBytes) != 1) {
        cerr << "Error reading the first line - memory limitation!" << endl;
        cerr << "Error reading the first line - memory limitation!" << endl;
        return;
    }
    if(memoryLimitInBytes <= 0) {
        cerr << "Memory limitation must be a positive integer!" << endl;
        return;
    }

    // Get the size of input file in bytes
    int fsize = filesize(input_file);
    // Calculate the number of temporary files needed based on memory limitation
    num_ways = ceil(double(fsize) / double(memoryLimitInBytes));

    // output scratch files
    FILE* out[num_ways];
    char fileName[20];
    for (int i = 0; i < num_ways; i++) {
        // convert i to string
        snprintf(fileName, sizeof(fileName), "tempFile%d", i);

        // Open output files in write mode.
        out[i] = openFile(fileName, (char*)"w");
    }

    // Creat a vector of KVPairs to store the input
    // Ignored the memory consumption of this KVPair array
    vector<KVPair> arr;

    bool more_input = true;
    int next_output_file = 0;
    int i;
    while (more_input) {
        arr.clear();
        long long byteCount = 0;
        // make sure not breaking the memory limit
        for (i = 0; byteCount < memoryLimitInBytes; i++) {
            // assume the key and value length will be less than 100
            char key[100];
            char value[100];
            // read out each key value pair from temporary input file
            if (fscanf(in, "%s %s\n", key, value) != 2) {
                more_input = false;
                break;
            }
            KVPair k;
            k.key = key;
            k.value = value;
            arr.push_back(k);
            byteCount += k.key.size() + k.value.size();
        }

        // sort array by comparing key first. If draw, compare value.
        sort(arr.begin(),arr.end(), [](KVPair& a, KVPair& b) {
            if(a.key ==b.key) {
                return a.value < b.value;
            }
            return a.key < b.key;
        });

        // Write the records to the output file
        for (int j = 0; j < i; j++) {
            fprintf(out[next_output_file], "%s %s\n", arr[j].key.c_str(), arr[j].value.c_str());
        }

        next_output_file++;
    }

    // close input and output files
    for (int i = 0; i < num_ways; i++) {
        fclose(out[i]);
    }
    fclose(in);
}

// For sorting data stored on disk
void externalSort(char* input_file) {
    // read the input file, create the initial runs,
    // and assign the runs to the output file
    splitInputFile(input_file);

    // Merge the runs using the K-way merging
    mergeTempFiles();
}

void generateInput(char* input_file, int ml, int es) {

}

// Driver program to test above
int main() {
    // Creat temporary input file from stdin
    char input_file[] = "tempInput.txt";
    FILE* in = openFile(input_file, (char*)"w");
    string memoryLimit;
    string key, value;
    cin >> memoryLimit;
    fprintf(in, "%s\n", memoryLimit.c_str());
    while(cin >> key && cin >> value) {
        fprintf(in, "%s %s\n", key.c_str(), value.c_str());
    }
    fclose(in);

    // Real processing begin
    externalSort(input_file);

    return 0;
}
